//+------------------------------------------------------------------+
//| File: London_SwingTrend_EURUSD_H1.mq5                            |
//| EA  : London_SwingTrend_EURUSD_H1                                |
//| Ver : 0.1.1-track                                                |
//|                                                                  |
//| London Swing Trend (EURUSD / H1)                                 |
//| - Trend: EMA(50) vs EMA(200) on last CLOSED bar                  |
//| - Entry: RSI pullback in trend direction (closed bar)            |
//| - Volatility filter: ATR must exceed minimum (in pips)           |
//| - Optional quality filter: ADX >= threshold (avoid dead market)  |
//| - Stops: SL = ATR * mult, TP = SL * R multiple                   |
//| - Optional trailing: ATR step after price moves >= R threshold   |
//| - Session: London hours via fixed UTC offset input (no DST auto) |
//| - Safety: spread gate, daily cap, cooldown, loss streak          |
//| - Risk exits: max-hold close, optional weekend flatten           |
//| - Positioning: 1 position per EA instance (symbol + magic)       |
//| - Execution: market orders (price=0)                             |
//| - Tracking: OPEN/CLOSE via KurosawaTrack.mqh                     |
//|                                                                  |
//| Notes                                                            |
//| - Attach ONLY to EURUSD H1 chart.                                |
//| - Signals use CLOSED BAR values (shift=1).                       |
//| - Entry evaluated once per NEW BAR.                              |
//| - If this EA "doesn't trade", check daily block counters.        |
//+------------------------------------------------------------------+
#property strict

#include <Trade/Trade.mqh>
#include "KurosawaHelpers.mqh"
#include "KurosawaTrack.mqh"

CTrade trade;

//==================== Identity ====================//
input int    InpMagic              = 2026011301;
input string InpEaId               = "ea-london-swingtrend-eurusd-h1";
input string InpEaName             = "London_SwingTrend_EURUSD_H1";
input string InpEaVersion          = "0.1.1";

//==================== Session: London (fixed UTC offset) ====================//
// This EA uses a FIXED UTC offset (no DST auto detection).
// Typical values:
// - Winter (GMT): 0
// - Summer (BST): +1
input int    InpSessionStartHour   = 8;   // London morning start
input int    InpSessionEndHour     = 18;  // London active hours end
input int    InpSessionUtcOffset   = 0;   // set +1 for BST if desired

//==================== Strategy: Trend & Pullback ====================//
// Trend definition: EMA(50) vs EMA(200)
// - Faster EMA/slow EMA are on CLOSED bar (shift=1)
input int    InpEmaFast            = 50;
input int    InpEmaSlow            = 200;

// Pullback trigger: RSI reverts into "pullback zone" inside the trend
// - Uptrend  : buy when RSI <= BuyPullback
// - Downtrend: sell when RSI >= SellPullback
input int    InpRsiPeriod          = 14;
input double InpRsiBuyPullback     = 45.0;
input double InpRsiSellPullback    = 55.0;

//==================== Market Quality Filters ====================//
// ATR minimum (pips):
// - Higher => fewer trades, avoids flat hours
// - Lower  => more trades, but can include chop/low-move candles
input int    InpAtrPeriod          = 14;
input double InpAtrMinPips         = 6.0;

// ADX filter (optional):
// For swing-trend, we often want SOME strength to avoid drifting entries.
// - If you see too few trades due to ADX blocks, lower MinAdxToTrade or disable.
// - If you see too many weak trend trades, raise MinAdxToTrade.
input bool   InpUseAdxFilter       = true;
input int    InpAdxPeriod          = 14;
input double InpMinAdxToTrade      = 18.0;

//==================== Stops & Exit Management ====================//
// SL distance = ATR * SlAtrMult
// TP distance = SL distance * TpRMultiple
input double InpSlAtrMult          = 2.0;
input double InpTpRMultiple        = 2.5;

// Trailing (optional):
// - Starts after price moves >= TrailStartR * initial risk (1R, etc.)
// - Then trails with ATR step size (ATR * TrailStepAtrMult)
input bool   InpUseTrailing        = true;
input double InpTrailStartR        = 1.0;
input double InpTrailStepAtrMult   = 0.7;

// Time stop (optional):
// Close position if held longer than this many hours.
input int    InpMaxHoldHours       = 120;   // 0 disables

//==================== Risk & Safety ====================//
// Spread gate (points). EURUSD typical is small, but spikes exist.
// - Keep enabled unless you have a reason.
input double InpMaxSpreadPoints    = 25.0;  // 0 disables

// Frequency / safety stops
input int    InpMaxTradesPerDay    = 4;
input int    InpCooldownMinutes    = 60;
input int    InpMaxConsecLosses    = 3;

// Weekend flatten (optional) in "session local time" hours
input bool   InpCloseBeforeWeekend = true;
input int    InpFridayCloseHour    = 20;

//==================== Tracking ====================//
input bool   InpTrackEnable        = true;
input bool   InpTrackSendOpen      = true;

//==================== Indicator Handles ====================//
int hEmaFast = INVALID_HANDLE;
int hEmaSlow = INVALID_HANDLE;
int hRsi     = INVALID_HANDLE;
int hAtr     = INVALID_HANDLE;
int hAdx     = INVALID_HANDLE;

//==================== Runtime State ====================//
datetime g_lastBarTime     = 0;   // once-per-bar gate
datetime g_lastCloseTime   = 0;   // cooldown anchor (updated on CLOSE)

int      g_tradesToday     = 0;
int      g_consecLosses    = 0;
int      g_lastLocalYmd    = 0;

// tracking dedupe guards
ulong    g_lastOpenDealId  = 0;
ulong    g_lastClosedDealId = 0;

// diagnostics (daily)
int g_diagBars      = 0;
int g_diagSignal    = 0;
int g_diagTradeSent = 0;

// block counters (daily, counted per evaluated BAR)
int g_blockSession  = 0;
int g_blockSpread   = 0;
int g_blockMaxDay   = 0;
int g_blockLoss     = 0;
int g_blockCooldown = 0;
int g_blockHasPos   = 0;
int g_blockAtr      = 0;
int g_blockAdx      = 0;
int g_blockNoSignal = 0;
int g_blockStops    = 0;
int g_blockOrderFail = 0;

//+------------------------------------------------------------------+
//| Local time helpers (fixed-offset)                                |
//+------------------------------------------------------------------+
datetime NowLocal()
{
   // Uses the same helper naming as your JST helper, but with any fixed offset.
   // NOTE: This does not auto-handle DST.
   return NowJst(InpSessionUtcOffset);
}

int LocalYmd()
{
   return JstYmd(NowLocal());
}

bool IsEntryTimeLocal()
{
   // Helper supports cross-midnight sessions: start > end
   return IsEntryTimeJST(InpSessionStartHour, InpSessionEndHour, InpSessionUtcOffset);
}

bool IsWeekendWindowLocal()
{
   MqlDateTime dt;
   TimeToStruct(NowLocal(), dt);
   return ((dt.day_of_week == 5 && dt.hour >= InpFridayCloseHour) || (dt.day_of_week == 6));
}

//+------------------------------------------------------------------+
//| Generic gates                                                    |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   const datetime t0 = iTime(_Symbol, PERIOD_H1, 0);
   if(t0 == g_lastBarTime) return false;
   g_lastBarTime = t0;
   return true;
}

bool SpreadOK(const double ask, const double bid)
{
   if(InpMaxSpreadPoints <= 0.0) return true;
   return ((ask - bid) / _Point) <= InpMaxSpreadPoints;
}

bool CooldownOK()
{
   if(InpCooldownMinutes <= 0) return true;
   if(g_lastCloseTime <= 0)    return true;
   return (TimeCurrent() - g_lastCloseTime) >= (InpCooldownMinutes * 60);
}

//+------------------------------------------------------------------+
//| Daily summary / reset                                            |
//+------------------------------------------------------------------+
void PrintDailySummary()
{
   PrintFormat(
      "Daily Summary: Bars=%d Signals=%d Trades=%d | Blocks session=%d spread=%d atr=%d adx=%d cooldown=%d haspos=%d loss=%d maxday=%d nosignal=%d stops=%d orderfail=%d",
      g_diagBars, g_diagSignal, g_diagTradeSent,
      g_blockSession, g_blockSpread, g_blockAtr, g_blockAdx, g_blockCooldown,
      g_blockHasPos, g_blockLoss, g_blockMaxDay, g_blockNoSignal,
      g_blockStops, g_blockOrderFail
   );
}

void ResetDailyIfNeeded()
{
   const int ymd = LocalYmd();
   if(ymd == g_lastLocalYmd) return;

   if(g_lastLocalYmd != 0)
      PrintDailySummary();

   g_lastLocalYmd = ymd;

   g_tradesToday = 0;
   // Do not blindly reset g_consecLosses if you want cross-day protection.
   // Here we reset daily to match your earlier pattern:
   g_consecLosses = 0;

   g_diagBars = 0;
   g_diagSignal = 0;
   g_diagTradeSent = 0;

   g_blockSession = 0;
   g_blockSpread = 0;
   g_blockMaxDay = 0;
   g_blockLoss = 0;
   g_blockCooldown = 0;
   g_blockHasPos = 0;
   g_blockAtr = 0;
   g_blockAdx = 0;
   g_blockNoSignal = 0;
   g_blockStops = 0;
   g_blockOrderFail = 0;
}

//+------------------------------------------------------------------+
//| Exit management                                                  |
//+------------------------------------------------------------------+
void CheckHoldTimeExit()
{
   if(InpMaxHoldHours <= 0) return;

   for(int i = PositionsTotal() - 1; i >= 0; --i)
   {
      const ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;

      if(!PositionSelectByTicket(ticket)) continue;
      if((int)PositionGetInteger(POSITION_MAGIC) != InpMagic) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;

      const datetime openT = (datetime)PositionGetInteger(POSITION_TIME);
      if(openT <= 0) continue;

      if((TimeCurrent() - openT) >= (InpMaxHoldHours * 3600))
      {
         trade.PositionClose(ticket);
         // cooldown anchor ideally updated on close deal, but keep local safety
         g_lastCloseTime = TimeCurrent();
         return;
      }
   }
}

void ManageTrailing()
{
   if(!InpUseTrailing) return;
   if(!PositionSelectByMagic(_Symbol, (long)InpMagic)) return;

   // ATR (shift=0) is fine for trailing.
   double atr0[1];
   if(CopyBuffer(hAtr, 0, 0, 1, atr0) != 1) return;

   const double atrNow = atr0[0];
   if(atrNow <= 0.0) return;

   const long   posType = PositionGetInteger(POSITION_TYPE);
   const double open    = PositionGetDouble(POSITION_PRICE_OPEN);
   const double slNow   = PositionGetDouble(POSITION_SL);
   const double tpNow   = PositionGetDouble(POSITION_TP);

   if(slNow <= 0.0) return;

   const double initialRisk = MathAbs(open - slNow);
   if(initialRisk <= 0.0) return;

   const double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   const double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   if(bid <= 0.0 || ask <= 0.0) return;

   if(posType == POSITION_TYPE_BUY)
   {
      if((bid - open) < (initialRisk * InpTrailStartR)) return;

      double proposedSl = NormalizeDouble(bid - (atrNow * InpTrailStepAtrMult), _Digits);

      double slTmp = proposedSl;
      double tpTmp = tpNow;
      if(!EnsureStopsLevel(_Symbol, bid, slTmp, tpTmp, true, true)) return;

      if(slNow == 0.0 || slTmp > slNow)
         trade.PositionModify(_Symbol, slTmp, tpNow);
   }
   else if(posType == POSITION_TYPE_SELL)
   {
      if((open - ask) < (initialRisk * InpTrailStartR)) return;

      double proposedSl = NormalizeDouble(ask + (atrNow * InpTrailStepAtrMult), _Digits);

      double slTmp = proposedSl;
      double tpTmp = tpNow;
      if(!EnsureStopsLevel(_Symbol, ask, slTmp, tpTmp, false, true)) return;

      if(slNow == 0.0 || slTmp < slNow)
         trade.PositionModify(_Symbol, slTmp, tpNow);
   }
}

//+------------------------------------------------------------------+
//| Init / Deinit                                                    |
//+------------------------------------------------------------------+
int OnInit()
{
   if(_Period != PERIOD_H1)
   {
      Print("CRITICAL: Attach this EA to an H1 chart.");
      return INIT_FAILED;
   }

   trade.SetExpertMagicNumber(InpMagic);

   hEmaFast = iMA(_Symbol, _Period, InpEmaFast, 0, MODE_EMA, PRICE_CLOSE);
   hEmaSlow = iMA(_Symbol, _Period, InpEmaSlow, 0, MODE_EMA, PRICE_CLOSE);
   hRsi     = iRSI(_Symbol, _Period, InpRsiPeriod, PRICE_CLOSE);
   hAtr     = iATR(_Symbol, _Period, InpAtrPeriod);

   // Only create ADX handle if used (avoids wasted resources)
   if(InpUseAdxFilter)
      hAdx = iADX(_Symbol, _Period, InpAdxPeriod);

   if(hEmaFast == INVALID_HANDLE || hEmaSlow == INVALID_HANDLE ||
      hRsi     == INVALID_HANDLE || hAtr     == INVALID_HANDLE ||
      (InpUseAdxFilter && hAdx == INVALID_HANDLE))
   {
      Print("CRITICAL: Indicator handle creation failed.");
      return INIT_FAILED;
   }

   g_lastLocalYmd = LocalYmd();
   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
   if(hEmaFast != INVALID_HANDLE) IndicatorRelease(hEmaFast);
   if(hEmaSlow != INVALID_HANDLE) IndicatorRelease(hEmaSlow);
   if(hRsi     != INVALID_HANDLE) IndicatorRelease(hRsi);
   if(hAtr     != INVALID_HANDLE) IndicatorRelease(hAtr);
   if(hAdx     != INVALID_HANDLE) IndicatorRelease(hAdx);
}

//+------------------------------------------------------------------+
//| OnTick                                                           |
//+------------------------------------------------------------------+
void OnTick()
{
   // 1) Daily rollover (local date)
   ResetDailyIfNeeded();

   // 2) Weekend flatten (optional)
   if(InpCloseBeforeWeekend && IsWeekendWindowLocal())
   {
      if(PositionExists(_Symbol, InpMagic))
         trade.PositionClose(_Symbol);
      return;
   }

   // 3) Exit management every tick
   CheckHoldTimeExit();
   ManageTrailing();

   // 4) Entry session gate (London hours via fixed offset)
   // Count blocks once per bar (after IsNewBar)
   if(!IsNewBar()) return;
   g_diagBars++;

   if(!IsEntryTimeLocal())
   {
      g_blockSession++;
      return;
   }

   // 5) Quotes & spread gate
   const double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   const double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if(ask <= 0.0 || bid <= 0.0) return;

   if(!SpreadOK(ask, bid))
   {
      g_blockSpread++;
      return;
   }

   // 6) Risk gates
   if(g_tradesToday >= InpMaxTradesPerDay) { g_blockMaxDay++; return; }
   if(g_consecLosses >= InpMaxConsecLosses) { g_blockLoss++; return; }
   if(!CooldownOK()) { g_blockCooldown++; return; }
   if(PositionExists(_Symbol, InpMagic)) { g_blockHasPos++; return; }

   // 7) Read CLOSED BAR (shift=1) indicator values
   double emaF1[1], emaS1[1], rsi1b[1], atr1b[1];
   if(CopyBuffer(hEmaFast, 0, 1, 1, emaF1) != 1) return;
   if(CopyBuffer(hEmaSlow, 0, 1, 1, emaS1) != 1) return;
   if(CopyBuffer(hRsi,     0, 1, 1, rsi1b) != 1) return;
   if(CopyBuffer(hAtr,     0, 1, 1, atr1b) != 1) return;

   const double emaFast1 = emaF1[0];
   const double emaSlow1 = emaS1[0];
   const double rsi1     = rsi1b[0];
   const double atr1     = atr1b[0];

   // 8) Quality filters
   // ATR minimum uses price units; convert from pips using helper.
   const double atrMinPrice = PipsToPrice(_Symbol, InpAtrMinPips);
   if(atr1 < atrMinPrice)
   {
      g_blockAtr++;
      return;
   }

   if(InpUseAdxFilter)
   {
      double adx1b[1];
      if(CopyBuffer(hAdx, 0, 1, 1, adx1b) != 1) return;
      const double adx1 = adx1b[0];

      if(adx1 < InpMinAdxToTrade)
      {
         g_blockAdx++;
         return;
      }
   }

   // 9) Trend & pullback signals
   const bool uptrend   = (emaFast1 > emaSlow1);
   const bool downtrend = (emaFast1 < emaSlow1);

   const bool buySig  = (uptrend   && rsi1 <= InpRsiBuyPullback);
   const bool sellSig = (downtrend && rsi1 >= InpRsiSellPullback);

   if(!buySig && !sellSig)
   {
      g_blockNoSignal++;
      return;
   }
   g_diagSignal++;

   // 10) Build ATR-based SL/TP
   const double slDist = atr1 * InpSlAtrMult;
   if(slDist <= 0.0) return;

   const double tpDist = slDist * InpTpRMultiple;

   const double lot = GetMinLot(_Symbol); // fixed-min lot (simple baseline)
   const string cmtBase = InpEaName + "|" + InpEaVersion;

   if(buySig)
   {
      double sl = NormalizeDouble(ask - slDist, _Digits);
      double tp = NormalizeDouble(ask + tpDist, _Digits);

      if(!EnsureStopsLevel(_Symbol, ask, sl, tp, true, true))
      {
         g_blockStops++;
         return;
      }

      if(!trade.Buy(lot, _Symbol, 0, sl, tp, cmtBase + "|BUY"))
      {
         g_blockOrderFail++;
         return;
      }

      g_tradesToday++;
      g_diagTradeSent++;
   }
   else
   {
      double sl = NormalizeDouble(bid + slDist, _Digits);
      double tp = NormalizeDouble(bid - tpDist, _Digits);

      if(!EnsureStopsLevel(_Symbol, bid, sl, tp, false, true))
      {
         g_blockStops++;
         return;
      }

      if(!trade.Sell(lot, _Symbol, 0, sl, tp, cmtBase + "|SELL"))
      {
         g_blockOrderFail++;
         return;
      }

      g_tradesToday++;
      g_diagTradeSent++;
   }
}

//+------------------------------------------------------------------+
//| Transaction Monitoring & Tracking (via KurosawaTrack.mqh)         |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                        const MqlTradeRequest& req,
                        const MqlTradeResult& res)
{
   // Delegate all tracking logic to your shared tracker
   KurosawaTrack_OnTradeTransaction(
      InpTrackEnable,
      trans,
      InpEaId,
      InpEaName,
      InpEaVersion,
       (int)InpMagic,
      InpTrackSendOpen,
      g_lastOpenDealId,
      g_lastClosedDealId,
      g_consecLosses,
      g_lastCloseTime,
      (ENUM_TIMEFRAMES)_Period,
      _Symbol 
   );
}
